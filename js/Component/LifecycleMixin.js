// Generated by CoffeeScript 1.12.4
var Builder, ReactComponent, assertType, emptyFunction, getListeners, instMixin, mixin, mutable, phaseNames, pushAll, runListeners, viewImpl;

mutable = require("Property").mutable;

ReactComponent = require("react/lib/ReactComponent");

emptyFunction = require("emptyFunction");

assertType = require("assertType");

Builder = require("Builder");

mixin = Builder.Mixin();

mixin.defineMethods({
  render: function(callback) {
    assertType(callback, Function);
    mutable.define(this, "_render", {
      value: callback
    });
  },
  shouldUpdate: function(callback) {
    assertType(callback, Function);
    mutable.define(this, "_shouldUpdate", {
      value: callback
    });
  },
  willReceiveProps: function(callback) {
    assertType(callback, Function);
    mutable.define(this, "_willReceiveProps", {
      value: callback
    });
  },
  willMount: function(callback) {
    assertType(callback, Function);
    this._phases.push("willMount", callback);
  },
  didMount: function(callback) {
    assertType(callback, Function);
    this._phases.push("didMount", callback);
  },
  willUpdate: function(callback) {
    assertType(callback, Function);
    this._phases.push("willUpdate", callback);
  },
  didUpdate: function(callback) {
    assertType(callback, Function);
    this._phases.push("didUpdate", callback);
  },
  willUnmount: function(callback) {
    assertType(callback, Function);
    this._phases.push("willUnmount", callback);
  }
});

mixin.initInstance(function() {
  return this.addMixin(instMixin.apply);
});

module.exports = mixin.apply;

instMixin = Builder.Mixin();

instMixin.willBuild(function() {
  var listeners;
  if (this._kind === ReactComponent) {
    this.defineMethods(viewImpl);
    this._delegate.defineMethods({
      __render: this._render || emptyFunction.thatReturnsFalse,
      __shouldUpdate: this._shouldUpdate || emptyFunction.thatReturnsTrue,
      __willReceiveProps: this._willReceiveProps || emptyFunction
    });
  } else {
    this._delegate.overrideMethods({
      __render: this._render,
      __shouldUpdate: this._shouldUpdate,
      __willReceiveProps: this._willReceiveProps
    });
  }
  listeners = getListeners(this._phases, this._kind.prototype);
  this.definePrototype(listeners);
});

viewImpl = {
  render: function() {
    return this._delegate.__render();
  },
  shouldComponentUpdate: function(nextProps) {
    return this._delegate.__shouldUpdate(nextProps);
  },
  componentWillReceiveProps: function(nextProps) {
    return this._delegate.__willReceiveProps(nextProps);
  },
  componentWillMount: function() {
    return runListeners(this, "__willMount");
  },
  componentDidMount: function() {
    return runListeners(this, "__didMount");
  },
  componentWillUpdate: function() {
    return runListeners(this, "__willUpdate");
  },
  componentDidUpdate: function() {
    return runListeners(this, "__didUpdate");
  },
  componentWillUnmount: function() {
    return runListeners(this, "__willUnmount");
  }
};

phaseNames = ["willMount", "didMount", "willUpdate", "didUpdate", "willUnmount"];

pushAll = Function.apply.bind([].push);

getListeners = function(phases, inherited) {
  var array, i, key, len, map, phaseName;
  map = {};
  for (i = 0, len = phaseNames.length; i < len; i++) {
    phaseName = phaseNames[i];
    if (!phases.has(phaseName)) {
      continue;
    }
    key = "__" + phaseName;
    if (inherited[key]) {
      array = [];
      pushAll(array, inherited[key]);
      pushAll(array, phases.get(phaseName));
      map[key] = array;
    } else {
      map[key] = phases.get(phaseName);
    }
  }
  return map;
};

runListeners = function(instance, phase) {
  var index, length, listeners;
  listeners = instance[phase];
  if (!(length = listeners != null ? listeners.length : void 0)) {
    return;
  }
  if (length === 1) {
    listeners[0].call(instance._delegate);
    return;
  }
  index = -1;
  while (++index < length) {
    listeners[index].call(instance._delegate);
  }
};
