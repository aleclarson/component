// Generated by CoffeeScript 1.11.1
var Builder, BuilderMixin, PropValidator, ReactComponent, assertType, frozen, gatherTypes, getKind, getParentType, getProto, has, hook, inArray, mutable, ref, superWrap;

ref = require("Property"), mutable = ref.mutable, frozen = ref.frozen;

ReactComponent = require("ReactComponent");

assertType = require("assertType");

getProto = require("getProto");

Builder = require("Builder");

getKind = require("getKind");

inArray = require("in-array");

hook = require("hook");

has = require("has");

PropValidator = require("../utils/PropValidator");

module.exports = (function() {
  var mixin;
  mixin = Builder.Mixin();
  mixin.initInstance(function() {
    this._phases.props = [];
    return BuilderMixin.apply(this);
  });
  mixin.defineMethods({
    inheritProps: function(type, options) {
      var exclude, key, propConfigs, propType, propTypes, ref1, requiredProps;
      ref1 = type.componentType || type, propTypes = ref1.propTypes, requiredProps = ref1.requiredProps;
      propConfigs = {};
      exclude = options != null ? options.exclude : void 0;
      for (key in propTypes) {
        propType = propTypes[key];
        if (!inArray(exclude, key)) {
          propConfigs[key] = requiredProps[key] ? {
            type: propType,
            required: true
          } : propType;
        }
      }
      this.defineProps(propConfigs);
    },
    definePropDefaults: function(values) {
      var props;
      props = this._props || this._createProps();
      props.setDefaults(values);
    },
    defineProps: function(propConfigs) {
      var props;
      props = this._props || this._createProps();
      props.define(propConfigs);
    },
    replaceProps: function(func) {
      assertType(func, Function);
      this._phases.props.unshift(func);
    },
    initProps: function(func) {
      assertType(func, Function);
      this._phases.props.push(function(props) {
        func.call(this, props);
        return props;
      });
    },
    _createProps: function() {
      var props, statics;
      frozen.define(this, "_props", {
        value: props = PropValidator()
      });
      this._delegate.defineStatics(statics = {
        propTypes: props.types,
        propDefaults: props.defaults,
        requiredProps: props.requiredKeys
      });
      if (this._delegate !== this) {
        this.defineStatics(statics);
      }
      this._phases.props.push(props.validate);
      return props;
    }
  });
  return mixin.apply;
})();

BuilderMixin = (function() {
  var didBuild, mixin, willReceiveProps;
  mixin = Builder.Mixin();
  mixin.defineStatics({
    parseProps: function(input) {
      var componentType, componentTypes, i, key, len, propType, propTypes, props;
      assertType(input, Object);
      props = {};
      componentTypes = gatherTypes(this.componentType || this);
      for (i = 0, len = componentTypes.length; i < len; i++) {
        componentType = componentTypes[i];
        if (propTypes = componentType.propTypes) {
          for (key in propTypes) {
            propType = propTypes[key];
            if (input[key] === void 0) {
              continue;
            }
            if (props[key] !== void 0) {
              continue;
            }
            props[key] = input[key];
          }
        }
      }
      return props;
    }
  });
  mixin.initInstance(function() {
    var delegate;
    delegate = this._delegate;
    if (delegate !== this) {
      delegate._props = this.props;
    }
  });
  mixin.willBuild(function() {
    var initProps, propPhases, superImpl;
    propPhases = this._phases.props;
    if (propPhases.length) {
      initProps = function(props) {
        var i, len, phase;
        for (i = 0, len = propPhases.length; i < len; i++) {
          phase = propPhases[i];
          props = phase.call(null, props);
        }
        return props;
      };
    }
    if (superImpl = this._kind && this._kind.initProps) {
      initProps = superWrap(initProps, superImpl);
    }
    initProps && this.didBuild(function(type) {
      return frozen.define(type, "initProps", {
        value: initProps
      });
    });
    hook(this, "_willReceiveProps", willReceiveProps);
    return this.didBuild(didBuild);
  });
  willReceiveProps = function(orig, props) {
    var delegate;
    orig.call(this, props);
    if (delegate = props.delegate) {
      delegate._props = props;
    }
  };
  didBuild = function(type) {
    if (ReactComponent !== getKind(type)) {
      return;
    }
    if (has(type.prototype, "_delegate")) {
      return;
    }
    return mutable.define(type.prototype, "_delegate", {
      get: function() {
        return this;
      }
    });
  };
  return mixin;
})();

superWrap = function(initProps, superImpl) {
  if (initProps) {
    return function(props) {
      return superImpl(initProps(props));
    };
  } else {
    return superImpl;
  }
};

gatherTypes = function(type) {
  var types;
  types = [type];
  while (type !== Object) {
    type = getParentType(type);
    types.push(type);
  }
  return types;
};

getParentType = function(type) {
  return getProto(type.prototype).constructor;
};
