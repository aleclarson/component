// Generated by CoffeeScript 1.12.4
var Builder, PropValidator, PropWatcher, ReactComponent, ViewMixin, assertType, emptyFunction, frozen, gatherTypes, getProto, has, inArray, mutable, ref, superWrap;

ref = require("Property"), mutable = ref.mutable, frozen = ref.frozen;

ReactComponent = require("react/lib/ReactComponent");

emptyFunction = require("emptyFunction");

assertType = require("assertType");

getProto = require("getProto");

Builder = require("Builder");

inArray = require("in-array");

has = require("has");

PropValidator = require("../utils/PropValidator");

PropWatcher = require("../utils/PropWatcher");

module.exports = (function() {
  var mixin;
  mixin = Builder.Mixin();
  mixin.initInstance(function() {
    this.willBuild(function() {
      return ViewMixin.apply(this);
    });
  });
  mixin.defineMethods({
    inheritProps: function(type, options) {
      var exclude, key, propConfigs, propType, propTypes, ref1, requiredProps;
      ref1 = type.componentType || type, propTypes = ref1.propTypes, requiredProps = ref1.requiredProps;
      propConfigs = {};
      exclude = options != null ? options.exclude : void 0;
      for (key in propTypes) {
        propType = propTypes[key];
        if (!inArray(exclude, key)) {
          propConfigs[key] = requiredProps[key] ? {
            type: propType,
            required: true
          } : propType;
        }
      }
      this.defineProps(propConfigs);
    },
    definePropDefaults: function(values) {
      var props;
      props = this._props || this._createProps();
      props.setDefaults(values);
    },
    defineProps: function(propConfigs) {
      var props;
      props = this._props || this._createProps();
      props.define(propConfigs);
    },
    replaceProps: function(callback) {
      assertType(callback, Function);
      this._phases.unshift("props", callback);
    },
    initProps: function(callback) {
      assertType(callback, Function);
      this._phases.push("props", function(props) {
        callback.call(this, props);
        return props;
      });
    },
    watchProp: function(key, callback) {
      var watcher;
      watcher = this._needs("propWatcher") ? this._watchProps() : this._propWatcher;
      watcher.add(key, callback);
    },
    _createProps: function() {
      var key, props, statics, value;
      frozen.define(this, "_props", {
        value: props = PropValidator()
      });
      statics = {
        propTypes: props.types,
        propDefaults: props.defaults,
        requiredProps: props.requiredKeys
      };
      for (key in statics) {
        value = statics[key];
        statics[key] = {
          value: value
        };
      }
      this._delegate.defineStatics(statics);
      if (this._delegate !== this) {
        this.defineStatics(statics);
      }
      this._phases.push("props", props.validate);
      return props;
    },
    _watchProps: function() {
      var watcher;
      frozen.define(this, "_propWatcher", {
        value: watcher = PropWatcher()
      });
      this.defineListeners(function() {
        return watcher.start(this.props, this);
      });
      this.willReceiveProps(function(props) {
        return watcher.update(props, this);
      });
      return watcher;
    }
  });
  return mixin.apply;
})();

ViewMixin = (function() {
  var mixin;
  mixin = Builder.Mixin();
  mixin.defineStatics({
    parseProps: function(input) {
      var componentType, componentTypes, i, key, len, propType, propTypes, props;
      assertType(input, Object);
      props = {};
      componentTypes = gatherTypes(this.componentType || this);
      for (i = 0, len = componentTypes.length; i < len; i++) {
        componentType = componentTypes[i];
        if (propTypes = componentType.propTypes) {
          for (key in propTypes) {
            propType = propTypes[key];
            if (input[key] === void 0) {
              continue;
            }
            if (props[key] !== void 0) {
              continue;
            }
            props[key] = input[key];
          }
        }
      }
      return props;
    }
  });
  mixin.willBuild((function() {
    var PropInitializer, attachProps, setDefaultDelegate;
    PropInitializer = function(kind, phases) {
      var initProps, superImpl;
      if (phases.length) {
        initProps = function(props) {
          var i, len, phase;
          for (i = 0, len = phases.length; i < len; i++) {
            phase = phases[i];
            props = phase.call(null, props);
          }
          return props;
        };
      }
      if (superImpl = kind && kind.initProps) {
        return superWrap(initProps, superImpl);
      } else {
        return initProps;
      }
    };
    setDefaultDelegate = function(prototype) {
      if (has(prototype, "_delegate")) {
        return;
      }
      if (getProto(prototype).constructor === ReactComponent) {
        mutable.define(prototype, "_delegate", {
          get: function() {
            return this;
          }
        });
      }
    };
    attachProps = function(props) {
      var delegate;
      if (delegate = props.delegate) {
        delegate._props = props;
      }
    };
    return function() {
      var initProps, willReceiveProps;
      this._values.unshift(attachProps);
      willReceiveProps = this._willReceiveProps || emptyFunction;
      this._willReceiveProps = function(props) {
        attachProps(props);
        willReceiveProps.call(this, props);
      };
      initProps = PropInitializer(this._kind, this._phases.get("props"));
      return this.didBuild(function(type) {
        frozen.define(type, "initProps", {
          value: initProps
        });
        setDefaultDelegate(type.prototype);
      });
    };
  })());
  return mixin;
})();

superWrap = function(initProps, superImpl) {
  if (initProps) {
    return function(props) {
      return superImpl(initProps(props));
    };
  } else {
    return superImpl;
  }
};

gatherTypes = function(type) {
  var types;
  types = [type];
  while (type !== Object) {
    type = getProto(type.prototype).constructor;
    types.push(type);
  }
  return types;
};
