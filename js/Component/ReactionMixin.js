// Generated by CoffeeScript 1.12.4
var AnimatedValue, ListenerMixin, Mixin, Random, Reaction, ValueMapper, assertType, bind, defineReactions, emptyFunction, frozen, isDev, isType, mixin, sync;

AnimatedValue = require("Animated").AnimatedValue;

ListenerMixin = require("Event").ListenerMixin;

frozen = require("Property").frozen;

emptyFunction = require("emptyFunction");

ValueMapper = require("ValueMapper");

assertType = require("assertType");

Reaction = require("Reaction");

Random = require("random");

isType = require("isType");

isDev = require("isDev");

bind = require("bind");

sync = require("sync");

Mixin = require("./Mixin");

module.exports = function(type) {
  return type.defineMethods({
    defineReactions: defineReactions
  });
};

mixin = Mixin();

mixin.defineValues(function() {
  return {
    __reactions: Object.create(null)
  };
});

mixin.didBuild(function(type) {
  return frozen.define(type.prototype, "_hasReactions", {
    value: true
  });
});

defineReactions = function(reactions) {
  var createReactions, delegate, id, kind, mapValues;
  isDev && assertType(reactions, Object.or(Function));
  delegate = this._delegate;
  if (!delegate._hasReactions) {
    frozen.define(delegate, "_hasReactions", {
      value: true
    });
    kind = delegate._kind;
    if (!(kind && kind.prototype._hasReactions)) {
      mixin.apply(delegate);
    }
  }
  id = Random.id();
  delegate.willUnmount(function() {
    var i, len, reaction, ref;
    ref = this.__reactions[id];
    for (i = 0, len = ref.length; i < len; i++) {
      reaction = ref[i];
      reaction.stop();
    }
    return delete this.__reactions[id];
  });
  if (isType(reactions, Function)) {
    createReactions = reactions;
    delegate.didMount(function() {
      var cache, onInit;
      this.__reactions[id] = cache = [];
      onInit = function(reaction) {
        return cache.push(reaction.start());
      };
      onInit = Reaction.didInit(onInit).start();
      createReactions.apply(this, arguments);
      return onInit.detach();
    });
    return;
  }
  sync.each(reactions, function(reaction, key) {
    if (isType(reaction, Function)) {
      return reactions[key] = emptyFunction.thatReturns(reaction);
    }
  });
  mapValues = ValueMapper(reactions, function(obj, key, getter) {
    var options, reaction, value;
    if (getter === void 0) {
      return;
    }
    isDev && assertType(getter, Reaction.or(Function, Object));
    value = AnimatedValue(null);
    frozen.define(obj, key, {
      value: value
    });
    if (isType(getter, Function)) {
      options = {
        get: bind.func(getter, obj),
        didSet: function(newValue) {
          if (newValue !== value.get()) {
            return value._updateValue(newValue);
          }
        }
      };
    } else if (isType(getter, Object)) {
      options = getter;
      options.didSet = (function() {
        var didSet;
        didSet = options.didSet || emptyFunction;
        return function(newValue) {
          if (newValue !== value.get()) {
            value._updateValue(newValue);
            return didSet.call(obj, newValue);
          }
        };
      })();
    }
    reaction = options ? Reaction(options) : getter;
    if (reaction.keyPath == null) {
      reaction.keyPath = obj.constructor.name + "." + key;
    }
    return obj.__reactions[id].push(reaction);
  });
  delegate._phases.init.push(function(args) {
    this.__reactions[id] = [];
    return mapValues(this, args);
  });
  return delegate.willMount(function() {
    var i, len, reaction, ref;
    ref = this.__reactions[id];
    for (i = 0, len = ref.length; i < len; i++) {
      reaction = ref[i];
      reaction.start();
    }
  });
};
